/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include <stdbool.h>
#include "main.h"
#include "can.h"
#include "tim.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */


#define motor_num 5

// 定义异常
typedef enum {
	MOTOR_ERROR = -1,
    MOTOR_INIT = 0,
    MOTOR_HOME,
    MOTOR_READY,
	MOTOR_MOVING
} MotorStatusEnum;

// 定义电机结构�?
typedef struct {
    uint8_t id;				//1,2,3,4,5
    MotorStatusEnum status;
    int32_t positionA;
    int32_t positionB;

    uint8_t go_home_flag;
    uint8_t go_pos_flag;
    uint8_t refuelling_flag;

    uint8_t cmdAB;		//1:A,2:B
    uint8_t relAB;		//0:running
} MotorStatus;

MotorStatus motor_statuses[motor_num];  //n�?

typedef enum {
	POS_H=0,    //home
    POS_A,	    //A:in
    POS_B,		//B:out
    IN_PROCESS,
    DAMAGED     //被损坏的
} LayerState;

LayerState current_state[motor_num];

uint32_t tick;
bool inputs[8]; //输入检测


int positionA[motor_num]={0,0,0,5000,0};
int positionB[motor_num]={0,0,0,-4000,0};



/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
//CAN1配置函数
void CAN1_Config(void)
{
  CAN_FilterTypeDef  sFilterConfig;

  /* Configure the CAN Filter */
  sFilterConfig.FilterBank = 0;                      // 过滤器编号，使用�??个CAN，则可�??0-13；使用两个CAN可�??0-27
  sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;  // 过滤器模式，掩码模式或列表模�??
  sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT; // 过滤器位�??
  sFilterConfig.FilterIdHigh = 0x0000;               // 过滤器验证码ID�??16位，0-0xFFFF
  sFilterConfig.FilterIdLow = 0x0000;                // 过滤器验证码ID�??16位，0-0xFFFF
  sFilterConfig.FilterMaskIdHigh = 0x0000;           // 过滤器掩码ID�??16位，0-0xFFFF
  sFilterConfig.FilterMaskIdLow = 0x0000;            // 过滤器掩码ID�??16位，0-0xFFFF
  sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0; // FIFOx�??0�??1
  sFilterConfig.FilterActivation = ENABLE;           // 使能过滤�??
  sFilterConfig.SlaveStartFilterBank = 14;           // 从过滤器编号�??0-27，对于单CAN实例该参数没有意�??

  if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK)
  {
    /* Filter configuration Error */
  }

  /* Start the CAN peripheral */
  if (HAL_CAN_Start(&hcan1) != HAL_OK)
  {
    /* Start Error */
  }

  /* Activate CAN RX notification */
  if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
  {
    /* Notification Error */
  }
}

//uint16_t  CAN_ID;
uint8_t txBuffer[8];

//CAN CRC校验 在数据段
uint8_t canCRC_ATM(uint8_t *buf,uint8_t len,uint8_t id) //CRC_SUM8
{
	uint32_t i;
	uint8_t check_sum;
	uint32_t sum = 0;

	for(i=0;i<len;i++)
	{
		sum += buf[i];
	}
	sum += id;//CAN_ID;
	check_sum = sum & 0xFF;
	return check_sum;
}

//CAN 发送数据
uint8_t CAN1_Send_Msg(uint8_t* msg, uint8_t len, uint16_t id)
{
  uint8_t i=0;
  uint8_t message[8];
  uint32_t TxMailbox;
  CAN_TxHeaderTypeDef CAN_TxHeader;

  CAN_TxHeader.StdId = id;                 // 标准标识(12bit)
  CAN_TxHeader.ExtId = id;                 // 扩展标识(29bit)
  CAN_TxHeader.IDE = CAN_ID_STD;           // 标准
  CAN_TxHeader.RTR = CAN_RTR_DATA;         // 数据
  CAN_TxHeader.DLC = len;
  CAN_TxHeader.TransmitGlobalTime = DISABLE;

  for(i = 0; i < len-1; i++)
  {
    message[i] = msg[i];
  }
  message[len-1] = canCRC_ATM(msg,len-1,id);

  if(HAL_CAN_AddTxMessage(&hcan1, &CAN_TxHeader, message, &TxMailbox) != HAL_OK)
  {
    return 1;
  }
  // 等待 CAN1 所有 3 个发送邮箱都变空
  while(HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) != 3)
  {

  }
  return 0;
}

void motorGoHome(uint8_t slaveAddr)
{
  txBuffer[0] = 0x91;
  CAN1_Send_Msg(txBuffer,2,slaveAddr);
}

//指定电机运行到绝对位置
void motorGoPosition(uint8_t slaveAddr,uint16_t speed,uint16_t acc,int32_t pos)
{
  txBuffer[0] = 0xF5;       		//FD:相对脉冲(16细分*200),FE:绝对脉冲
  	  	  	  	  	  	  	  	  	//F4:相对坐标,F5:绝对坐标(16384/r)

  txBuffer[1] = (speed>>8)&0x00FF;  //
  txBuffer[2] = speed&0x00FF;
  txBuffer[3] = acc;
  txBuffer[4] = (pos >> 16)&0xFF;  // bit23 - bit16
  txBuffer[5] = (pos >> 8)&0xFF;   // bit15 - bit8
  txBuffer[6] = (pos >> 0)&0xFF;   // bit7 - bit0
  CAN1_Send_Msg(txBuffer,8,slaveAddr);
}

 //读取电机的绝对位置
void motorReadPosition(uint8_t slaveAddr)
{
	txBuffer[0] = 0x31;
	CAN1_Send_Msg(txBuffer,2,slaveAddr);

}

//CAN 接收回调函数
void canDataReceived(uint8_t *buf, uint8_t len, uint8_t id)
{

	int i;
	for(i=0;i<motor_num;i++)
	{
		if(id==i+1)
		{
			if(buf[0]==0x91 && buf[1]==0x02 )//回零结束应答
			{
				motor_statuses[i].status = MOTOR_READY;
				motor_statuses[i].go_home_flag=1;
			}

			if(buf[0]==0xF5 && buf[1]==0x00)//位置控制失败应答
			{
				motor_statuses[i].status = MOTOR_ERROR;
			}
			if(buf[0]==0xF5 && buf[1]==0x02 )//位置控制成功应答
			{
				motor_statuses[i].go_pos_flag=1;
			}
			break;
		}

	}
}


//读取所有的输入状态并执行相应动作  X5读取机器人是否出错      *    *
//                                                            *
void read_all()	//all inputs
{
	// 测试代码重构2
		uint8_t i;
		for(i=0;i<8;i++)
		{
			inputs[i]=false;
		}
		if(HAL_GPIO_ReadPin(X1_GPIO_Port, X1_Pin)==0)	inputs[0]=true;			//电机1 2 cw/ccw
		if(HAL_GPIO_ReadPin(X2_GPIO_Port, X2_Pin)==0)	inputs[1]=true;			//电机3 4 cw/ccw
		if(HAL_GPIO_ReadPin(X3_GPIO_Port, X3_Pin)==0)	inputs[2]=true;			//电机5 cw/ccw
		if(HAL_GPIO_ReadPin(X4_GPIO_Port, X4_Pin)==0)	inputs[3]=true;         //电机4 cw/ccw
		if(HAL_GPIO_ReadPin(X5_GPIO_Port, X5_Pin)==0)	inputs[4]=true;			//电机5 cw/ccw
		if(HAL_GPIO_ReadPin(X6_GPIO_Port, X6_Pin)==0)	inputs[5]=true;
		if(HAL_GPIO_ReadPin(X7_GPIO_Port, X7_Pin)==0)	inputs[6]=true;
		if(HAL_GPIO_ReadPin(X8_GPIO_Port, X8_Pin)==0)	inputs[7]=true;
}

//uint8_t JudgeState(uint8_t startID,uint8_t num,uint16_t speed,uint16_t acc)
//{
//	uint8_t i=num,state=1;
//
////
//	for (i=0;i<num;i++)
//	{
//		if(current_state[i+startID-1]==POS_H)
//		{
//			if(motor_statuses[i+startID-1].go_home_flag==1)
//				state=1;
//			else
//				state=0;
//		}
//	}
//
//	if(state==1)
//	{
//		for(i=0;i<num;i++)
//		{
//			current_state[i+startID-1]=POS_A;
//			motorGoPosition(i+startID,speed,speed,motor_statuses[i+startID-1].positionA);
//			motor_statuses[i+startID-1].go_home_flag=0;
//		}
//		state=0;
//		return 0;
//	}
//
//
//	//
//	for (i=0;i<num;i++)
//	{
//		if(current_state[startID+i-1]==POS_A)
//		{
//			if(motor_statuses[startID+i-1].go_pos_flagA==1)
//				state=1;
//			else
//				state=0;
//		}
//	}
//
//	if(state==1)
//	{
//		for(i=0;i<num;i++)
//		{
//			current_state[i+startID-1]=POS_B;
//			motorGoPosition(i+startID,speed,speed,motor_statuses[i+startID-1].positionB);
//			motor_statuses[startID+i-1].go_pos_flagA=0;
//		}
//		state=0;
//		return 0;
//	}
//
//
//	//
//	for (i=0;i<num;i++)
//	{
//		if(current_state[startID+i-1]==POS_B)
//		{
//			if(motor_statuses[startID+i-1].go_pos_flagB==1)
//				state=1;
//			else
//				state=0;
//		}
//	}
//
//	if(state==1)
//	{
//		for(i=0;i<num;i++)
//		{
//			current_state[i+startID-1]=POS_A;
//			motorGoPosition(i+startID,speed,speed,motor_statuses[i+startID-1].positionA);
//			motor_statuses[i+startID-1].go_pos_flagB=0;
//		}
//		state=0;
//		return 0;
//	}
//
//	return 1;
//}
//
//uint8_t JudgeState(uint8_t startID, uint8_t num, uint16_t speed, uint16_t acc)
//{
//    uint8_t all_ready;
//    uint8_t i;
//
//    // === 第一步：POS_H → POS_A ===
//    all_ready = 1;
//    for (i = 0; i < num; i++) {
//        uint8_t idx = startID + i - 1;
//        if (current_state[idx] != POS_H || motor_statuses[idx].go_home_flag != 1) {
//            all_ready = 0;
//            break;
//        }
//    }
//
//    if (all_ready) {
//        for (i = 0; i < num; i++) {
//            uint8_t idx = startID + i - 1;
//            current_state[idx] = POS_A;
//            motorGoPosition(idx + 1, speed, acc, motor_statuses[idx].positionA);
//            motor_statuses[idx].go_home_flag = 0;
//        }
//        return 0;  // 状态推进了一步
//    }
//
//    // === 第二步：POS_A → POS_B ===
//    all_ready = 1;
//    for (i = 0; i < num; i++) {
//        uint8_t idx = startID + i - 1;
//        if (current_state[idx] != POS_A || motor_statuses[idx].go_pos_flagA != 1) {
//            all_ready = 0;
//            break;
//        }
//    }
//
//    if (all_ready) {
//        for (i = 0; i < num; i++) {
//            uint8_t idx = startID + i - 1;
//            current_state[idx] = POS_B;
//            motorGoPosition(idx + 1, speed, acc, motor_statuses[idx].positionB);
//            motor_statuses[idx].go_pos_flagA = 0;
//        }
//        return 0;
//    }
//
//    // === 第三步：POS_B → POS_A ===
//    all_ready = 1;
//    for (i = 0; i < num; i++) {
//        uint8_t idx = startID + i - 1;
//        if (current_state[idx] != POS_B || motor_statuses[idx].go_pos_flagB != 1) {
//            all_ready = 0;
//            break;
//        }
//    }
//
//    if (all_ready) {
//        for (i = 0; i < num; i++) {
//            uint8_t idx = startID + i - 1;
//            current_state[idx] = POS_A;
//            motorGoPosition(idx + 1, speed, acc, motor_statuses[idx].positionA);
//            motor_statuses[idx].go_pos_flagB = 0;
//        }
//        return 0;
//    }
//
//    // 当前无状态可推进，等待
//    return 1;
//}


void run_action()
{
	uint8_t i=motor_num;
	for(i=0;i<motor_num;i++)
	{
		switch(current_state[i])
		{
			case POS_H:
				if(motor_statuses[i].go_home_flag==1)
				{
					motor_statuses[i].go_home_flag=0;

					motorGoPosition(i+1,500,100,motor_statuses[i].positionA);//电机 POSA
					tick=0;
					current_state[i]=POS_A;
				}
				 // tick已经置为0了，再来判断tick==5000 是为了 防止第一个判断的flag不为1 而它还没到位
				if(tick==5000)
				{
					motorGoHome(i+1);//电机1 回零
				}
			break;

			case POS_A:
				if(motor_statuses[i].go_pos_flag==1)
				{
					tick=0;
					HAL_GPIO_WritePin(Y6_GPIO_Port, Y6_Pin, GPIO_PIN_SET);	//yellowled_R
					HAL_GPIO_WritePin(Y5_GPIO_Port, Y5_Pin, GPIO_PIN_RESET);//greenled_S
					HAL_GPIO_WritePin(Y1_GPIO_Port, Y1_Pin, GPIO_PIN_RESET);//POSA-Y1-cobot-S
//					if((inputs & (1<<(2*i))) !
					if(inputs[i]== true )
					{
						motor_statuses[i].go_pos_flag=0;
						HAL_GPIO_WritePin(Y5_GPIO_Port, Y5_Pin, GPIO_PIN_SET); //greenled_R
						HAL_GPIO_WritePin(Y1_GPIO_Port, Y1_Pin, GPIO_PIN_SET); //POSA-Y1-cobot-R

						motorGoPosition(i+1,500,100,motor_statuses[i].positionB);


						tick=0;
						current_state[i]=POS_B;
					}

				}
				if(tick==5000)
				{
					motorGoPosition(i+1,500,100,motor_statuses[i].positionA);//电机1: POSA
				}
			break;

			case POS_B:
				if(motor_statuses[i].go_pos_flag==1)
				{
					tick=0;
					HAL_GPIO_WritePin(Y5_GPIO_Port, Y5_Pin, GPIO_PIN_RESET);//greenled_S
					HAL_GPIO_WritePin(Y2_GPIO_Port, Y2_Pin, GPIO_PIN_RESET);//POSB-Y2-cobot-S
//					if((inputs & (1<<(2*i+1))) != 0)
					if(inputs[i]==true) //节约输入口
					{
						motor_statuses[i].go_pos_flag=0;
						HAL_GPIO_WritePin(Y5_GPIO_Port, Y5_Pin, GPIO_PIN_SET);//greenled_R
						HAL_GPIO_WritePin(Y2_GPIO_Port, Y2_Pin, GPIO_PIN_SET);//POSB-Y2-cobot-R

						motorGoPosition(i+1,500,100,motor_statuses[i].positionA);//电机1: POSA
						tick=0;
						current_state[i]=POS_A;
					}
				}
				if(tick==5000)
				{
					motorGoPosition(i+1,500,100,motor_statuses[i].positionA);//  POSA

				}
			break;

			case DAMAGED:

			break;

			default:
				break;
			}
	}

//	if(inputs[0]==true)
//	{
//		JudgeState(4,1,500,100);
//	}
//	if(inputs[1]==true)
//	{
//		JudgeState(3,2,1000,100);
//	}
//	if(inputs[2]==true)
//	{
//		JudgeState(5,1,1000,100);
//	}

}

void Motor_Init(void)
{
	uint8_t i;

	for(i=0;i<motor_num;i++)
	{
//	 current_state[i]= POS_H;

	  motor_statuses[i].id = i+1;
	  motor_statuses[i].status = MOTOR_INIT;
	  motor_statuses[i].cmdAB = 0;
	  motor_statuses[i].relAB = 0;

	  motor_statuses[i].positionA = positionA[i];	//	//查询手册知道 正转一圈编码器值 +0x4000=16384 位置是以编码器的值为准的
	  motor_statuses[i].positionB = positionB[i];//

	}
//	for(i=0;i<motor_num;i++)
//	{
//		motorGoHome(i+1);
//	}

}


/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_TIM3_Init();
  MX_TIM6_Init();
  MX_CAN1_Init();
  /* USER CODE BEGIN 2 */
  CAN1_Config();
  /* USER CODE END 2 */

  /* Infinite loop */

  /* USER CODE BEGIN WHILE */
  HAL_Delay(1500);
  HAL_GPIO_WritePin(Y6_GPIO_Port, Y6_Pin, GPIO_PIN_RESET);//yellowled_S
  //初始化电机
   Motor_Init();
   motorGoHome(4);

  while (1)
  {
//    /* USER CODE END WHILE */
//
//    /* USER CODE BEGIN 3 */
	read_all();
	run_action();
	HAL_Delay(50);
	tick++;
	HAL_GPIO_TogglePin(LED3_GPIO_Port, LED3_Pin);
  }

  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
